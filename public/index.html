<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RealtimeKit - Global SFU Architecture</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --cf-orange: #F38020;
      --cf-orange-light: #F5A623;
      --cf-orange-dark: #E55C00;
      --cf-gray-900: #1a1a1a;
      --cf-gray-800: #2d2d2d;
      --cf-gray-700: #404040;
      --cf-gray-600: #525252;
      --cf-gray-400: #9CA3AF;
      --cf-gray-300: #D1D5DB;
      --cf-gray-100: #F3F4F6;
      --cf-white: #FFFFFF;
      --participant-blue: #3B82F6;
      --participant-green: #10B981;
      --backbone-yellow: #F59E0B;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--cf-gray-900);
      color: var(--cf-gray-100);
      min-height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 24px;
      background: rgba(0, 0, 0, 0.4);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 100;
      flex-shrink: 0;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: var(--cf-orange);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo-icon svg {
      width: 20px;
      height: 20px;
      fill: white;
    }

    .logo-text {
      font-size: 16px;
      font-weight: 600;
      color: var(--cf-white);
    }

    .logo-subtitle {
      font-size: 12px;
      color: var(--cf-gray-400);
      margin-left: 8px;
      padding-left: 8px;
      border-left: 1px solid var(--cf-gray-600);
    }

    .header-stats {
      display: flex;
      align-items: center;
      gap: 24px;
      font-size: 13px;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--cf-gray-400);
    }

    .stat-value {
      color: var(--cf-orange);
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    .main-content {
      flex: 1;
      display: flex;
      position: relative;
      overflow: hidden;
      min-height: 0;
    }

    #map-container {
      flex: 1;
      position: relative;
      background: #0a1628;
      overflow: hidden;
    }

    #map-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #map-svg:active {
      cursor: grabbing;
    }

    .zoom-controls {
      position: absolute;
      bottom: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 60;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: var(--cf-gray-100);
      font-size: 20px;
      font-weight: 300;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .zoom-btn:hover {
      background: rgba(243, 128, 32, 0.8);
    }

    .zoom-btn:active {
      transform: scale(0.95);
    }

    .zoom-info {
      text-align: center;
      font-size: 10px;
      color: var(--cf-gray-400);
      padding: 4px 0;
    }

    .land {
      fill: #1e3a5f;
      stroke: none;
    }

    .graticule {
      fill: none;
      stroke: rgba(255, 255, 255, 0.03);
      stroke-width: 0.5;
    }

    .dc-marker {
      cursor: pointer;
    }

    .dc-dot {
      fill: var(--cf-orange);
      filter: drop-shadow(0 0 3px var(--cf-orange));
      transition: r 0.2s ease;
    }

    .dc-marker:hover .dc-dot {
      r: 4;
    }

    .dc-ring {
      fill: none;
      stroke: var(--cf-orange);
      stroke-width: 0.5;
      opacity: 0.3;
    }

    .participant-marker {
      cursor: pointer;
    }

    .participant-dot {
      fill: var(--participant-blue);
      filter: drop-shadow(0 0 4px var(--participant-blue));
    }

    .participant-dot.speaker {
      fill: var(--participant-green);
      filter: drop-shadow(0 0 4px var(--participant-green));
    }

    .participant-pulse {
      fill: none;
      stroke: var(--participant-blue);
      stroke-width: 1;
      opacity: 0;
      animation: pulse 2s ease-out infinite;
    }

    .participant-pulse.speaker {
      stroke: var(--participant-green);
    }

    @keyframes pulse {
      0% { r: 3; opacity: 0.8; }
      100% { r: 12; opacity: 0; }
    }

    .connection-line {
      fill: none;
      stroke-linecap: round;
    }

    .user-dc-line {
      stroke: var(--cf-orange);
      stroke-width: 0.8;
      opacity: 0.7;
    }

    .dc-dc-line {
      stroke: var(--backbone-yellow);
      stroke-width: 1;
      stroke-dasharray: 4, 2;
      opacity: 0.6;
      animation: dash 1s linear infinite;
    }

    @keyframes dash {
      to { stroke-dashoffset: -6; }
    }

    .click-hint {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 12px;
      color: var(--cf-gray-300);
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 50;
    }

    .click-hint.hidden { opacity: 0; }
    .click-hint span { color: var(--cf-orange); }

    .sidebar {
      width: 300px;
      background: rgba(0, 0, 0, 0.6);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      flex-direction: column;
      z-index: 50;
      flex-shrink: 0;
      overflow-y: auto;
    }

    .sidebar-section {
      padding: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sidebar-section:last-child { border-bottom: none; }

    .section-title {
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--cf-orange);
      margin-bottom: 10px;
    }

    .mode-toggle {
      display: flex;
      background: var(--cf-gray-800);
      border-radius: 8px;
      padding: 4px;
      gap: 4px;
    }

    .mode-btn {
      flex: 1;
      padding: 8px 12px;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: var(--cf-gray-400);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .mode-btn:hover { color: var(--cf-gray-100); }
    .mode-btn.active { background: var(--cf-orange); color: var(--cf-white); }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 14px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-primary { background: var(--cf-orange); color: var(--cf-white); }
    .btn-primary:hover { background: var(--cf-orange-light); }
    .btn-secondary { background: var(--cf-gray-700); color: var(--cf-gray-100); }
    .btn-secondary:hover { background: var(--cf-gray-600); }
    .btn-danger { background: transparent; border: 1px solid rgba(239, 68, 68, 0.5); color: #EF4444; }
    .btn-danger:hover { background: rgba(239, 68, 68, 0.1); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn-row { display: flex; gap: 8px; }
    .btn-row .btn { flex: 1; }

    .legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 11px;
      color: var(--cf-gray-300);
    }

    .legend-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .legend-dot.datacenter { background: var(--cf-orange); box-shadow: 0 0 6px var(--cf-orange); }
    .legend-dot.participant { background: var(--participant-blue); box-shadow: 0 0 6px var(--participant-blue); }
    .legend-dot.speaker { background: var(--participant-green); box-shadow: 0 0 6px var(--participant-green); }

    .legend-line { width: 20px; height: 2px; border-radius: 2px; }
    .legend-line.user-dc { background: var(--cf-orange); }
    .legend-line.dc-dc {
      background: repeating-linear-gradient(90deg, var(--backbone-yellow) 0, var(--backbone-yellow) 3px, transparent 3px, transparent 6px);
    }

    .info-panel {
      background: rgba(243, 128, 32, 0.1);
      border: 1px solid rgba(243, 128, 32, 0.3);
      border-radius: 8px;
      padding: 12px;
    }

    .info-panel p {
      font-size: 11px;
      line-height: 1.5;
      color: var(--cf-gray-300);
      margin-bottom: 6px;
    }

    .info-panel p:last-child { margin-bottom: 0; }
    .info-panel strong { color: var(--cf-orange); }

    .tooltip {
      position: fixed;
      background: var(--cf-gray-800);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 11px;
      color: var(--cf-gray-100);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 1000;
      white-space: nowrap;
    }

    .tooltip.visible { opacity: 1; }
    .tooltip-title { font-weight: 600; margin-bottom: 2px; }
    .tooltip-subtitle { color: var(--cf-gray-400); font-size: 10px; }

    .loading-overlay {
      position: absolute;
      inset: 0;
      background: var(--cf-gray-900);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 200;
      transition: opacity 0.5s ease;
    }

    .loading-overlay.hidden { opacity: 0; pointer-events: none; }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--cf-gray-700);
      border-top-color: var(--cf-orange);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { color: var(--cf-gray-400); font-size: 14px; }

    @media (max-width: 768px) {
      .main-content { flex-direction: column; }
      .sidebar { width: 100%; max-height: 180px; flex-direction: row; flex-wrap: wrap; }
      .sidebar-section { flex: 1; min-width: 150px; padding: 12px; }
      .header-stats { display: none; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <div class="logo-icon">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
          </svg>
        </div>
        <span class="logo-text">RealtimeKit</span>
        <span class="logo-subtitle">Global SFU Architecture</span>
      </div>
      <div class="header-stats">
        <div class="stat">
          <span>Participants:</span>
          <span class="stat-value" id="participant-count">0</span>
          <span>/ 100</span>
        </div>
        <div class="stat">
          <span>Active DCs:</span>
          <span class="stat-value" id="active-dc-count">0</span>
          <span>/ <span id="total-dc-count">0</span></span>
        </div>
      </div>
    </header>

    <div class="main-content">
      <div id="map-container">
        <div class="loading-overlay" id="loading">
          <div class="spinner"></div>
          <div class="loading-text">Loading map...</div>
        </div>
        <svg id="map-svg" viewBox="0 0 1000 500" preserveAspectRatio="xMidYMid meet"></svg>
        <div class="click-hint" id="click-hint">
          <span>Single-click</span> to add participant | <span>Double-click</span> to zoom | <span>Drag</span> to pan
        </div>
        <div class="zoom-controls">
          <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
          <div class="zoom-info" id="zoom-level">1x</div>
          <button class="zoom-btn" id="zoom-out" title="Zoom Out">−</button>
          <button class="zoom-btn" id="zoom-reset" title="Reset View" style="margin-top: 8px; font-size: 14px;">⌂</button>
        </div>
      </div>

      <aside class="sidebar">
        <div class="sidebar-section">
          <div class="section-title">Connection Mode</div>
          <div class="mode-toggle">
            <button class="mode-btn active" data-mode="mesh" id="btn-mesh">Full Mesh</button>
            <button class="mode-btn" data-mode="speaker" id="btn-speaker">Speaker</button>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="section-title">Controls</div>
          <div class="controls">
            <button class="btn btn-primary" id="btn-random">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/>
              </svg>
              Add Random Participant
            </button>
            <button class="btn btn-danger" id="btn-clear">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
              </svg>
              Clear All
            </button>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="section-title">Legend</div>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-icon"><div class="legend-dot datacenter"></div></div>
              <span>Cloudflare Datacenter</span>
            </div>
            <div class="legend-item">
              <div class="legend-icon"><div class="legend-dot participant"></div></div>
              <span>Participant</span>
            </div>
            <div class="legend-item" id="legend-speaker" style="display: none;">
              <div class="legend-icon"><div class="legend-dot speaker"></div></div>
              <span>Speaker (Broadcasting)</span>
            </div>
            <div class="legend-item">
              <div class="legend-icon"><div class="legend-line user-dc"></div></div>
              <span>User to Datacenter</span>
            </div>
            <div class="legend-item">
              <div class="legend-icon"><div class="legend-line dc-dc"></div></div>
              <span>Backbone (DC to DC)</span>
            </div>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="section-title">How It Works</div>
          <div class="info-panel">
            <p><strong>Anycast Routing:</strong> Users connect to their nearest datacenter automatically.</p>
            <p><strong>Global SFU:</strong> Media routes through Cloudflare's backbone - no central server.</p>
            <p><strong>Edge Processing:</strong> Packet recovery at the edge for lower latency.</p>
          </div>
        </div>
      </aside>
    </div>
  </div>

  <div class="tooltip" id="tooltip">
    <div class="tooltip-title"></div>
    <div class="tooltip-subtitle"></div>
  </div>

  <script>
    // =====================================================
    // CONFIGURATION - ~100 Cloudflare Datacenters
    // =====================================================
    
    const DATACENTERS = [
      // North America - USA
      { id: 'SFO', name: 'San Francisco', lat: 37.77, lng: -122.42 },
      { id: 'LAX', name: 'Los Angeles', lat: 34.05, lng: -118.24 },
      { id: 'SEA', name: 'Seattle', lat: 47.61, lng: -122.33 },
      { id: 'DEN', name: 'Denver', lat: 39.74, lng: -104.99 },
      { id: 'DFW', name: 'Dallas', lat: 32.78, lng: -96.80 },
      { id: 'ORD', name: 'Chicago', lat: 41.88, lng: -87.63 },
      { id: 'IAD', name: 'Ashburn', lat: 39.05, lng: -77.49 },
      { id: 'EWR', name: 'Newark', lat: 40.69, lng: -74.17 },
      { id: 'ATL', name: 'Atlanta', lat: 33.75, lng: -84.39 },
      { id: 'MIA', name: 'Miami', lat: 25.76, lng: -80.19 },
      { id: 'BOS', name: 'Boston', lat: 42.36, lng: -71.06 },
      { id: 'PHX', name: 'Phoenix', lat: 33.45, lng: -112.07 },
      { id: 'SLC', name: 'Salt Lake City', lat: 40.76, lng: -111.89 },
      { id: 'MSP', name: 'Minneapolis', lat: 44.98, lng: -93.27 },
      { id: 'PDX', name: 'Portland', lat: 45.52, lng: -122.68 },
      { id: 'SAN', name: 'San Diego', lat: 32.72, lng: -117.16 },
      { id: 'LAS', name: 'Las Vegas', lat: 36.17, lng: -115.14 },
      { id: 'IAH', name: 'Houston', lat: 29.76, lng: -95.37 },
      { id: 'PHL', name: 'Philadelphia', lat: 39.95, lng: -75.17 },
      { id: 'CLT', name: 'Charlotte', lat: 35.23, lng: -80.84 },
      { id: 'DTW', name: 'Detroit', lat: 42.33, lng: -83.05 },
      { id: 'TPA', name: 'Tampa', lat: 27.95, lng: -82.46 },
      // North America - Canada
      { id: 'YYZ', name: 'Toronto', lat: 43.65, lng: -79.38 },
      { id: 'YVR', name: 'Vancouver', lat: 49.28, lng: -123.12 },
      { id: 'YUL', name: 'Montreal', lat: 45.50, lng: -73.57 },
      { id: 'YYC', name: 'Calgary', lat: 51.05, lng: -114.07 },
      // North America - Mexico
      { id: 'MEX', name: 'Mexico City', lat: 19.43, lng: -99.13 },
      { id: 'GDL', name: 'Guadalajara', lat: 20.67, lng: -103.35 },
      // Europe - Western
      { id: 'LHR', name: 'London', lat: 51.51, lng: -0.13 },
      { id: 'AMS', name: 'Amsterdam', lat: 52.37, lng: 4.90 },
      { id: 'FRA', name: 'Frankfurt', lat: 50.11, lng: 8.68 },
      { id: 'CDG', name: 'Paris', lat: 48.86, lng: 2.35 },
      { id: 'DUB', name: 'Dublin', lat: 53.35, lng: -6.26 },
      { id: 'MAD', name: 'Madrid', lat: 40.42, lng: -3.70 },
      { id: 'BCN', name: 'Barcelona', lat: 41.39, lng: 2.17 },
      { id: 'MXP', name: 'Milan', lat: 45.46, lng: 9.19 },
      { id: 'ZRH', name: 'Zurich', lat: 47.37, lng: 8.54 },
      { id: 'BRU', name: 'Brussels', lat: 50.85, lng: 4.35 },
      { id: 'VIE', name: 'Vienna', lat: 48.21, lng: 16.37 },
      { id: 'LIS', name: 'Lisbon', lat: 38.72, lng: -9.14 },
      { id: 'MAN', name: 'Manchester', lat: 53.48, lng: -2.24 },
      { id: 'MUC', name: 'Munich', lat: 48.14, lng: 11.58 },
      { id: 'CPH', name: 'Copenhagen', lat: 55.68, lng: 12.57 },
      { id: 'OSL', name: 'Oslo', lat: 59.91, lng: 10.75 },
      { id: 'HEL', name: 'Helsinki', lat: 60.17, lng: 24.94 },
      // Europe - Eastern
      { id: 'ARN', name: 'Stockholm', lat: 59.33, lng: 18.07 },
      { id: 'WAW', name: 'Warsaw', lat: 52.23, lng: 21.01 },
      { id: 'PRG', name: 'Prague', lat: 50.08, lng: 14.44 },
      { id: 'BUD', name: 'Budapest', lat: 47.50, lng: 19.04 },
      { id: 'SOF', name: 'Sofia', lat: 42.70, lng: 23.32 },
      { id: 'OTP', name: 'Bucharest', lat: 44.43, lng: 26.10 },
      { id: 'KIV', name: 'Chisinau', lat: 47.01, lng: 28.86 },
      { id: 'ATH', name: 'Athens', lat: 37.98, lng: 23.73 },
      { id: 'IST', name: 'Istanbul', lat: 41.01, lng: 28.98 },
      // Asia - East
      { id: 'NRT', name: 'Tokyo', lat: 35.68, lng: 139.65 },
      { id: 'KIX', name: 'Osaka', lat: 34.69, lng: 135.50 },
      { id: 'ICN', name: 'Seoul', lat: 37.57, lng: 126.98 },
      { id: 'HKG', name: 'Hong Kong', lat: 22.32, lng: 114.17 },
      { id: 'TPE', name: 'Taipei', lat: 25.03, lng: 121.57 },
      // Asia - Southeast
      { id: 'SIN', name: 'Singapore', lat: 1.35, lng: 103.82 },
      { id: 'BKK', name: 'Bangkok', lat: 13.76, lng: 100.50 },
      { id: 'KUL', name: 'Kuala Lumpur', lat: 3.14, lng: 101.69 },
      { id: 'CGK', name: 'Jakarta', lat: -6.21, lng: 106.85 },
      { id: 'MNL', name: 'Manila', lat: 14.60, lng: 120.98 },
      { id: 'SGN', name: 'Ho Chi Minh', lat: 10.82, lng: 106.63 },
      { id: 'HAN', name: 'Hanoi', lat: 21.03, lng: 105.85 },
      // Asia - South
      { id: 'BOM', name: 'Mumbai', lat: 19.08, lng: 72.88 },
      { id: 'DEL', name: 'New Delhi', lat: 28.61, lng: 77.21 },
      { id: 'MAA', name: 'Chennai', lat: 13.08, lng: 80.27 },
      { id: 'BLR', name: 'Bangalore', lat: 12.97, lng: 77.59 },
      { id: 'HYD', name: 'Hyderabad', lat: 17.38, lng: 78.49 },
      { id: 'CCU', name: 'Kolkata', lat: 22.57, lng: 88.36 },
      { id: 'CMB', name: 'Colombo', lat: 6.93, lng: 79.85 },
      { id: 'DAC', name: 'Dhaka', lat: 23.81, lng: 90.41 },
      { id: 'KHI', name: 'Karachi', lat: 24.86, lng: 67.01 },
      // Middle East
      { id: 'DXB', name: 'Dubai', lat: 25.20, lng: 55.27 },
      { id: 'DOH', name: 'Doha', lat: 25.29, lng: 51.53 },
      { id: 'BAH', name: 'Bahrain', lat: 26.07, lng: 50.56 },
      { id: 'KWI', name: 'Kuwait', lat: 29.38, lng: 47.99 },
      { id: 'MCT', name: 'Muscat', lat: 23.59, lng: 58.54 },
      { id: 'TLV', name: 'Tel Aviv', lat: 32.09, lng: 34.78 },
      { id: 'AMM', name: 'Amman', lat: 31.95, lng: 35.93 },
      // Africa
      { id: 'JNB', name: 'Johannesburg', lat: -26.20, lng: 28.05 },
      { id: 'CPT', name: 'Cape Town', lat: -33.92, lng: 18.42 },
      { id: 'NBO', name: 'Nairobi', lat: -1.29, lng: 36.82 },
      { id: 'LOS', name: 'Lagos', lat: 6.52, lng: 3.38 },
      { id: 'CAI', name: 'Cairo', lat: 30.04, lng: 31.24 },
      { id: 'CMN', name: 'Casablanca', lat: 33.57, lng: -7.59 },
      { id: 'ADD', name: 'Addis Ababa', lat: 9.00, lng: 38.76 },
      { id: 'ACC', name: 'Accra', lat: 5.56, lng: -0.19 },
      { id: 'DKR', name: 'Dakar', lat: 14.69, lng: -17.45 },
      // Oceania
      { id: 'SYD', name: 'Sydney', lat: -33.87, lng: 151.21 },
      { id: 'MEL', name: 'Melbourne', lat: -37.81, lng: 144.96 },
      { id: 'BNE', name: 'Brisbane', lat: -27.47, lng: 153.03 },
      { id: 'PER', name: 'Perth', lat: -31.95, lng: 115.86 },
      { id: 'AKL', name: 'Auckland', lat: -36.85, lng: 174.76 },
      // South America
      { id: 'GRU', name: 'Sao Paulo', lat: -23.55, lng: -46.63 },
      { id: 'GIG', name: 'Rio de Janeiro', lat: -22.91, lng: -43.17 },
      { id: 'EZE', name: 'Buenos Aires', lat: -34.60, lng: -58.38 },
      { id: 'SCL', name: 'Santiago', lat: -33.45, lng: -70.67 },
      { id: 'BOG', name: 'Bogota', lat: 4.71, lng: -74.07 },
      { id: 'LIM', name: 'Lima', lat: -12.05, lng: -77.04 },
      { id: 'CCS', name: 'Caracas', lat: 10.48, lng: -66.88 },
      { id: 'MDE', name: 'Medellin', lat: 6.24, lng: -75.57 },
      { id: 'UIO', name: 'Quito', lat: -0.18, lng: -78.47 },
    ];

    // Fixed SVG coordinate system
    const SVG_WIDTH = 1000;
    const SVG_HEIGHT = 500;
    const MAP_BOUNDS = { minLat: -60, maxLat: 85, minLng: -180, maxLng: 180 };

    // =====================================================
    // STATE
    // =====================================================
    
    let svg, gConnections, gDatacenters, gParticipants;
    let participants = [];
    let participantIdCounter = 0;
    let mode = 'mesh';
    let speakerId = null;

    // Zoom/Pan state
    let viewBox = { x: 0, y: 0, w: SVG_WIDTH, h: SVG_HEIGHT };
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let panStartViewBox = { x: 0, y: 0, w: SVG_WIDTH, h: SVG_HEIGHT };
    let hasDragged = false;
    let clickTimeout = null;
    let pendingClick = null;
    const DRAG_THRESHOLD = 5; // pixels
    const DOUBLE_CLICK_DELAY = 250; // ms
    const MIN_ZOOM = 1;
    const MAX_ZOOM = 8;

    // =====================================================
    // COORDINATE CONVERSION (Fixed coordinate system)
    // =====================================================

    function latLngToXY(lat, lng) {
      const x = ((lng - MAP_BOUNDS.minLng) / (MAP_BOUNDS.maxLng - MAP_BOUNDS.minLng)) * SVG_WIDTH;
      const y = ((MAP_BOUNDS.maxLat - lat) / (MAP_BOUNDS.maxLat - MAP_BOUNDS.minLat)) * SVG_HEIGHT;
      return { x, y };
    }

    function xyToLatLng(x, y) {
      const lng = MAP_BOUNDS.minLng + (x / SVG_WIDTH) * (MAP_BOUNDS.maxLng - MAP_BOUNDS.minLng);
      const lat = MAP_BOUNDS.maxLat - (y / SVG_HEIGHT) * (MAP_BOUNDS.maxLat - MAP_BOUNDS.minLat);
      return { lat, lng };
    }

    function screenToSVG(screenX, screenY) {
      const ctm = svg.getScreenCTM();
      if (!ctm) return { x: 0, y: 0 };
      const pt = svg.createSVGPoint();
      pt.x = screenX;
      pt.y = screenY;
      const svgP = pt.matrixTransform(ctm.inverse());
      return { x: svgP.x, y: svgP.y };
    }

    function haversineDistance(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function findNearestDC(lat, lng) {
      let nearest = DATACENTERS[0];
      let minDist = Infinity;
      for (const dc of DATACENTERS) {
        const dist = haversineDistance(lat, lng, dc.lat, dc.lng);
        if (dist < minDist) { minDist = dist; nearest = dc; }
      }
      return nearest;
    }

    function randomLandLocation() {
      const regions = [
        { lat: [25, 50], lng: [-125, -70], weight: 20 },
        { lat: [35, 60], lng: [-10, 40], weight: 25 },
        { lat: [10, 45], lng: [70, 145], weight: 30 },
        { lat: [-35, -20], lng: [115, 155], weight: 10 },
        { lat: [-35, 5], lng: [-75, -35], weight: 10 },
        { lat: [-30, 35], lng: [15, 50], weight: 5 },
      ];
      const total = regions.reduce((s, r) => s + r.weight, 0);
      let rand = Math.random() * total;
      for (const r of regions) {
        rand -= r.weight;
        if (rand <= 0) return {
          lat: r.lat[0] + Math.random() * (r.lat[1] - r.lat[0]),
          lng: r.lng[0] + Math.random() * (r.lng[1] - r.lng[0])
        };
      }
      return { lat: 0, lng: 0 };
    }

    // =====================================================
    // SVG HELPERS
    // =====================================================

    function createSVGElement(tag, attrs = {}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
      return el;
    }

    function createCurvedPath(x1, y1, x2, y2, curve = 0.15) {
      const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
      const dx = x2 - x1, dy = y2 - y1;
      const cx = mx - dy * curve, cy = my + dx * curve;
      return `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;
    }

    // =====================================================
    // MAP INITIALIZATION
    // =====================================================

    async function initMap() {
      svg = document.getElementById('map-svg');
      
      const gBackground = createSVGElement('g', { class: 'background-layer' });
      gConnections = createSVGElement('g', { class: 'connections-layer' });
      gDatacenters = createSVGElement('g', { class: 'datacenters-layer' });
      gParticipants = createSVGElement('g', { class: 'participants-layer' });
      
      svg.appendChild(gBackground);
      svg.appendChild(gConnections);
      svg.appendChild(gDatacenters);
      svg.appendChild(gParticipants);
      
      await drawWorldMap(gBackground);
      drawGraticule(gBackground);
      drawDatacenters();
      
      document.getElementById('total-dc-count').textContent = DATACENTERS.length;
      svg.addEventListener('click', handleMapClick);
      document.getElementById('loading').classList.add('hidden');
    }

    async function drawWorldMap(group) {
      try {
        // Use countries GeoJSON for cleaner rendering
        const resp = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
        const topo = await resp.json();
        const countries = topojsonMesh(topo, topo.objects.countries);
        const land = topojsonMerge(topo, topo.objects.countries.geometries);
        
        // Draw land mass as filled shape
        if (land) {
          const pathData = geoPathFromGeometry(land);
          if (pathData) {
            group.appendChild(createSVGElement('path', { d: pathData, class: 'land' }));
          }
        }
      } catch (e) {
        console.warn('Map load failed:', e);
        group.appendChild(createSVGElement('rect', { x: 0, y: 0, width: SVG_WIDTH, height: SVG_HEIGHT, fill: '#1e3a5f', opacity: 0.3 }));
      }
    }

    // Simplified TopoJSON helpers
    function topojsonMerge(topology, geometries) {
      const arcs = topology.arcs;
      const transform = topology.transform;
      
      function decodeArc(arcIdx) {
        const arc = arcs[arcIdx < 0 ? ~arcIdx : arcIdx];
        const coords = [];
        let x = 0, y = 0;
        for (const point of arc) {
          x += point[0];
          y += point[1];
          coords.push([
            x * transform.scale[0] + transform.translate[0],
            y * transform.scale[1] + transform.translate[1]
          ]);
        }
        return arcIdx < 0 ? coords.reverse() : coords;
      }
      
      function decodeRing(ring) {
        const coords = [];
        for (const arcIdx of ring) {
          const arcCoords = decodeArc(arcIdx);
          // Skip first point if not first arc (avoid duplicates)
          const start = coords.length > 0 ? 1 : 0;
          for (let i = start; i < arcCoords.length; i++) {
            coords.push(arcCoords[i]);
          }
        }
        return coords;
      }
      
      const polygons = [];
      for (const geom of geometries) {
        if (geom.type === 'Polygon') {
          polygons.push(geom.arcs.map(decodeRing));
        } else if (geom.type === 'MultiPolygon') {
          for (const poly of geom.arcs) {
            polygons.push(poly.map(decodeRing));
          }
        }
      }
      
      return { type: 'MultiPolygon', coordinates: polygons };
    }

    function topojsonMesh(topology, obj) {
      return topojsonMerge(topology, obj.geometries || [obj]);
    }

    function geoPathFromGeometry(geom) {
      const toPath = (ring) => {
        if (!ring || ring.length < 3) return '';
        
        // Split ring at antimeridian crossings to avoid lines spanning the map
        const segments = [];
        let currentSegment = [];
        
        for (let i = 0; i < ring.length; i++) {
          const [lng, lat] = ring[i];
          const prevLng = i > 0 ? ring[i - 1][0] : null;
          
          // Detect antimeridian crossing (jump > 180 degrees)
          if (prevLng !== null && Math.abs(lng - prevLng) > 180) {
            // End current segment and start new one
            if (currentSegment.length > 0) {
              segments.push(currentSegment);
              currentSegment = [];
            }
          }
          
          currentSegment.push([lng, lat]);
        }
        
        if (currentSegment.length > 0) {
          segments.push(currentSegment);
        }
        
        // Convert segments to path strings
        return segments.map(seg => {
          if (seg.length < 2) return '';
          return seg.map(([lng, lat], i) => {
            const { x, y } = latLngToXY(lat, lng);
            return `${i === 0 ? 'M' : 'L'}${x.toFixed(1)} ${y.toFixed(1)}`;
          }).join('');
        }).filter(Boolean).join('');
      };
      
      if (geom.type === 'Polygon') {
        return geom.coordinates.map(toPath).filter(Boolean).join('');
      }
      if (geom.type === 'MultiPolygon') {
        return geom.coordinates.map(poly => poly.map(toPath).filter(Boolean).join('')).join('');
      }
      return '';
    }

    function drawGraticule(group) {
      // Subtle longitude lines every 60 degrees
      for (let lng = -120; lng <= 120; lng += 60) {
        const p1 = latLngToXY(MAP_BOUNDS.maxLat, lng), p2 = latLngToXY(MAP_BOUNDS.minLat, lng);
        group.appendChild(createSVGElement('line', { 
          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, 
          class: 'graticule' 
        }));
      }
      // Subtle latitude lines: equator and tropics
      for (const lat of [-30, 0, 30, 60]) {
        const p1 = latLngToXY(lat, MAP_BOUNDS.minLng), p2 = latLngToXY(lat, MAP_BOUNDS.maxLng);
        group.appendChild(createSVGElement('line', { 
          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, 
          class: 'graticule' 
        }));
      }
    }

    function drawDatacenters() {
      for (const dc of DATACENTERS) {
        const { x, y } = latLngToXY(dc.lat, dc.lng);
        const g = createSVGElement('g', { class: 'dc-marker', 'data-id': dc.id });
        g.appendChild(createSVGElement('circle', { cx: x, cy: y, r: 5, class: 'dc-ring' }));
        g.appendChild(createSVGElement('circle', { cx: x, cy: y, r: 2.5, class: 'dc-dot' }));
        g.addEventListener('mouseenter', (e) => showTooltip(e, dc.name, `Cloudflare PoP - ${dc.id}`));
        g.addEventListener('mouseleave', hideTooltip);
        gDatacenters.appendChild(g);
      }
    }

    // =====================================================
    // PARTICIPANTS
    // =====================================================

    function addParticipant(lat, lng, isSpeaker = false) {
      if (participants.length >= 100) return null;
      
      lat = Math.max(MAP_BOUNDS.minLat, Math.min(MAP_BOUNDS.maxLat, lat));
      lng = Math.max(MAP_BOUNDS.minLng, Math.min(MAP_BOUNDS.maxLng, lng));

      const dc = findNearestDC(lat, lng);
      const id = ++participantIdCounter;
      const p = { id, lat, lng, dcId: dc.id, dc, isSpeaker: isSpeaker || (mode === 'speaker' && participants.length === 0) };
      
      if (mode === 'speaker' && p.isSpeaker) speakerId = id;
      
      participants.push(p);
      drawParticipant(p);
      updateConnections();
      updateStats();
      return p;
    }

    function drawParticipant(p) {
      const { x, y } = latLngToXY(p.lat, p.lng);
      const g = createSVGElement('g', { class: 'participant-marker', 'data-id': p.id });
      g.appendChild(createSVGElement('circle', { cx: x, cy: y, r: 3, class: `participant-pulse ${p.isSpeaker ? 'speaker' : ''}` }));
      g.appendChild(createSVGElement('circle', { cx: x, cy: y, r: 4, class: `participant-dot ${p.isSpeaker ? 'speaker' : ''}` }));
      
      const dist = Math.round(haversineDistance(p.lat, p.lng, p.dc.lat, p.dc.lng));
      g.addEventListener('mouseenter', (e) => showTooltip(e, `Participant ${p.id}`, `Connected to ${p.dc.name} (${dist} km)`));
      g.addEventListener('mouseleave', hideTooltip);
      gParticipants.appendChild(g);
    }

    function clearParticipants() {
      participants = [];
      speakerId = null;
      participantIdCounter = 0;
      gParticipants.innerHTML = '';
      gConnections.innerHTML = '';
      updateStats();
      document.getElementById('click-hint').classList.remove('hidden');
    }

    function updateStats() {
      document.getElementById('participant-count').textContent = participants.length;
      document.getElementById('active-dc-count').textContent = new Set(participants.map(p => p.dcId)).size;
    }

    // =====================================================
    // CONNECTIONS
    // =====================================================

    function updateConnections() {
      gConnections.innerHTML = '';
      if (participants.length === 0) return;
      
      // User to DC
      for (const p of participants) {
        const pPos = latLngToXY(p.lat, p.lng);
        const dcPos = latLngToXY(p.dc.lat, p.dc.lng);
        gConnections.appendChild(createSVGElement('path', {
          d: createCurvedPath(pPos.x, pPos.y, dcPos.x, dcPos.y, 0.08),
          class: 'connection-line user-dc-line'
        }));
      }
      
      // DC to DC
      if (participants.length >= 2) {
        const activeDCs = [...new Set(participants.map(p => p.dcId))];
        
        if (mode === 'mesh') {
          for (let i = 0; i < activeDCs.length; i++) {
            for (let j = i + 1; j < activeDCs.length; j++) {
              const dc1 = DATACENTERS.find(d => d.id === activeDCs[i]);
              const dc2 = DATACENTERS.find(d => d.id === activeDCs[j]);
              const p1 = latLngToXY(dc1.lat, dc1.lng), p2 = latLngToXY(dc2.lat, dc2.lng);
              gConnections.appendChild(createSVGElement('path', {
                d: createCurvedPath(p1.x, p1.y, p2.x, p2.y, 0.1),
                class: 'connection-line dc-dc-line'
              }));
            }
          }
        } else {
          const speaker = participants.find(p => p.id === speakerId);
          if (speaker) {
            const sPos = latLngToXY(speaker.dc.lat, speaker.dc.lng);
            for (const dcId of activeDCs) {
              if (dcId !== speaker.dc.id) {
                const dc = DATACENTERS.find(d => d.id === dcId);
                const dPos = latLngToXY(dc.lat, dc.lng);
                gConnections.appendChild(createSVGElement('path', {
                  d: createCurvedPath(sPos.x, sPos.y, dPos.x, dPos.y, 0.1),
                  class: 'connection-line dc-dc-line'
                }));
              }
            }
          }
        }
      }
    }

    // =====================================================
    // MODE
    // =====================================================

    function setMode(newMode) {
      mode = newMode;
      document.getElementById('btn-mesh').classList.toggle('active', mode === 'mesh');
      document.getElementById('btn-speaker').classList.toggle('active', mode === 'speaker');
      document.getElementById('legend-speaker').style.display = mode === 'speaker' ? 'flex' : 'none';
      
      if (mode === 'mesh') {
        speakerId = null;
        participants.forEach(p => p.isSpeaker = false);
      } else if (participants.length > 0) {
        speakerId = participants[0].id;
        participants.forEach(p => p.isSpeaker = p.id === speakerId);
      }
      
      gParticipants.innerHTML = '';
      participants.forEach(drawParticipant);
      updateConnections();
    }

    // =====================================================
    // TOOLTIP
    // =====================================================

    function showTooltip(e, title, subtitle) {
      const tt = document.getElementById('tooltip');
      tt.querySelector('.tooltip-title').textContent = title;
      tt.querySelector('.tooltip-subtitle').textContent = subtitle || '';
      tt.style.left = (e.clientX + 12) + 'px';
      tt.style.top = (e.clientY - 10) + 'px';
      tt.classList.add('visible');
    }

    function hideTooltip() {
      document.getElementById('tooltip').classList.remove('visible');
    }

    // =====================================================
    // EVENT HANDLERS
    // =====================================================

    function handleMapClick(e) {
      // Don't process if we dragged
      if (hasDragged) return;
      if (e.target.closest('.dc-marker') || e.target.closest('.participant-marker')) return;
      if (participants.length >= 100) return;
      
      const clickX = e.clientX;
      const clickY = e.clientY;
      
      // If there's a pending click, this is a double-click
      if (pendingClick) {
        clearTimeout(clickTimeout);
        pendingClick = null;
        // Double-click zooms in
        zoomAt(clickX, clickY, 2);
        return;
      }
      
      // Set up pending click - wait to see if it's a double-click
      pendingClick = { x: clickX, y: clickY };
      clickTimeout = setTimeout(() => {
        if (pendingClick && !hasDragged) {
          const { x, y } = screenToSVG(pendingClick.x, pendingClick.y);
          const { lat, lng } = xyToLatLng(x, y);
          addParticipant(lat, lng);
          document.getElementById('click-hint').classList.add('hidden');
        }
        pendingClick = null;
      }, DOUBLE_CLICK_DELAY);
    }

    // =====================================================
    // ZOOM & PAN
    // =====================================================

    function getZoomLevel() {
      return SVG_WIDTH / viewBox.w;
    }

    function updateZoomDisplay() {
      const zoom = getZoomLevel();
      document.getElementById('zoom-level').textContent = zoom.toFixed(1) + 'x';
    }

    function setViewBox(x, y, w, h, animate = false) {
      // Clamp dimensions
      w = Math.max(SVG_WIDTH / MAX_ZOOM, Math.min(SVG_WIDTH, w));
      h = w * (SVG_HEIGHT / SVG_WIDTH);
      
      // Clamp position to keep map in view
      x = Math.max(0, Math.min(SVG_WIDTH - w, x));
      y = Math.max(0, Math.min(SVG_HEIGHT - h, y));
      
      viewBox = { x, y, w, h };
      
      if (animate) {
        svg.style.transition = 'viewBox 0.3s ease';
        setTimeout(() => svg.style.transition = '', 300);
      }
      
      svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
      updateZoomDisplay();
    }

    function zoomAt(clientX, clientY, factor) {
      const svgRect = svg.getBoundingClientRect();
      
      // Get the point in SVG coordinates where we want to zoom
      const svgPoint = screenToSVG(clientX, clientY);
      
      // Calculate new dimensions
      const newW = viewBox.w / factor;
      const newH = viewBox.h / factor;
      
      // Calculate the ratio of the point within the current viewBox
      const ratioX = (svgPoint.x - viewBox.x) / viewBox.w;
      const ratioY = (svgPoint.y - viewBox.y) / viewBox.h;
      
      // Calculate new position to keep the zoom point stationary
      const newX = svgPoint.x - ratioX * newW;
      const newY = svgPoint.y - ratioY * newH;
      
      setViewBox(newX, newY, newW, newH);
    }

    function zoomIn() {
      const centerX = viewBox.x + viewBox.w / 2;
      const centerY = viewBox.y + viewBox.h / 2;
      const newW = viewBox.w / 1.5;
      const newH = viewBox.h / 1.5;
      setViewBox(centerX - newW / 2, centerY - newH / 2, newW, newH, true);
    }

    function zoomOut() {
      const centerX = viewBox.x + viewBox.w / 2;
      const centerY = viewBox.y + viewBox.h / 2;
      const newW = viewBox.w * 1.5;
      const newH = viewBox.h * 1.5;
      setViewBox(centerX - newW / 2, centerY - newH / 2, newW, newH, true);
    }

    function resetZoom() {
      setViewBox(0, 0, SVG_WIDTH, SVG_HEIGHT, true);
    }

    function zoomToPoint(lat, lng, zoomLevel = 3) {
      const { x, y } = latLngToXY(lat, lng);
      const w = SVG_WIDTH / zoomLevel;
      const h = SVG_HEIGHT / zoomLevel;
      setViewBox(x - w / 2, y - h / 2, w, h, true);
    }

    function handleWheel(e) {
      e.preventDefault();
      const factor = e.deltaY < 0 ? 1.2 : 0.8;
      zoomAt(e.clientX, e.clientY, factor);
    }

    function handleMouseDown(e) {
      if (e.button !== 0) return; // Only left mouse button
      if (e.target.closest('.dc-marker') || e.target.closest('.participant-marker')) return;
      
      isPanning = true;
      hasDragged = false;
      panStart = { x: e.clientX, y: e.clientY };
      panStartViewBox = { ...viewBox };
    }

    function handleMouseMove(e) {
      if (!isPanning) return;
      
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      // Only start dragging if we've moved past threshold
      if (dist > DRAG_THRESHOLD) {
        hasDragged = true;
        svg.style.cursor = 'grabbing';
        
        // Cancel any pending click
        if (pendingClick) {
          clearTimeout(clickTimeout);
          pendingClick = null;
        }
      }
      
      if (hasDragged) {
        // Convert screen pixels to SVG units
        const svgRect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / svgRect.width;
        const scaleY = viewBox.h / svgRect.height;
        
        setViewBox(
          panStartViewBox.x - dx * scaleX,
          panStartViewBox.y - dy * scaleY,
          viewBox.w,
          viewBox.h
        );
      }
    }

    function handleMouseUp(e) {
      isPanning = false;
      svg.style.cursor = 'grab';
      
      // Reset hasDragged after a short delay so click handler can check it
      setTimeout(() => { hasDragged = false; }, 10);
    }

    function handleTouchStart(e) {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        isPanning = true;
        hasDragged = false;
        panStart = { x: touch.clientX, y: touch.clientY };
        panStartViewBox = { ...viewBox };
      }
    }

    function handleTouchMove(e) {
      if (!isPanning || e.touches.length !== 1) return;
      
      const touch = e.touches[0];
      const dx = touch.clientX - panStart.x;
      const dy = touch.clientY - panStart.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > DRAG_THRESHOLD) {
        hasDragged = true;
        e.preventDefault();
        
        const svgRect = svg.getBoundingClientRect();
        const scaleX = viewBox.w / svgRect.width;
        const scaleY = viewBox.h / svgRect.height;
        
        setViewBox(
          panStartViewBox.x - dx * scaleX,
          panStartViewBox.y - dy * scaleY,
          viewBox.w,
          viewBox.h
        );
      }
    }

    function handleTouchEnd() {
      isPanning = false;
      setTimeout(() => { hasDragged = false; }, 10);
    }



    // =====================================================
    // INIT
    // =====================================================

    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      
      // Mode buttons
      document.getElementById('btn-mesh').addEventListener('click', () => setMode('mesh'));
      document.getElementById('btn-speaker').addEventListener('click', () => setMode('speaker'));
      
      // Control buttons
      document.getElementById('btn-random').addEventListener('click', () => {
        const loc = randomLandLocation();
        addParticipant(loc.lat, loc.lng);
        document.getElementById('click-hint').classList.add('hidden');
      });
      document.getElementById('btn-clear').addEventListener('click', clearParticipants);
      
      // Zoom buttons
      document.getElementById('zoom-in').addEventListener('click', zoomIn);
      document.getElementById('zoom-out').addEventListener('click', zoomOut);
      document.getElementById('zoom-reset').addEventListener('click', resetZoom);
      
      // Mouse zoom/pan
      svg.addEventListener('wheel', handleWheel, { passive: false });
      svg.addEventListener('mousedown', handleMouseDown);
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      // Touch zoom/pan
      svg.addEventListener('touchstart', handleTouchStart, { passive: true });
      svg.addEventListener('touchmove', handleTouchMove, { passive: false });
      svg.addEventListener('touchend', handleTouchEnd);
      
      // Prevent default double-click text selection
      svg.addEventListener('dblclick', (e) => e.preventDefault());
      
      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (e.key === '+' || e.key === '=') { e.preventDefault(); zoomIn(); }
        if (e.key === '-' || e.key === '_') { e.preventDefault(); zoomOut(); }
        if (e.key === '0') { e.preventDefault(); resetZoom(); }
      });
    });
  </script>
</body>
</html>
